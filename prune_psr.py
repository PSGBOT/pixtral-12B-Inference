import json
import os
import networkx as nx
import argparse
from nx_utils.build_nx import read_rel_as_nx
from nx_utils.visualize import show_graph

from nx_utils.validate_graph import (
    detect_conflict_kr,
    detect_invalid_kr,
    detect_redundancy_kr,
    detect_cyclic_kr,
)

PSR_KR_CAT = [
    "fixed", # keep iff only "fixed" is detected
    "revolute-static",
    "prismatic-static",
    "spherical-static",
    "revolute-controlled",
    "prismatic-controlled",
    "spherical-controlled",
    "revolute-free",
    "prismatic-free",
    "spherical-free",
    "supported", # keep
    "flexible", # keep
    "unrelated", # ignore
    "unknown" # delete others if detected
]
# order
PSR_FUNC_CAT = [
    "other",
    "handle",
    "housing",
    "support",
    "frame",
    "button",
    "wheel",
    "display",
    "cover",
    "plug",
    "port",
    "door",
    "container",
]


def _parse_relations(relations):
    # relations is expected to be a dictionary, e.g., {'type': 'revolute-free', 'root_index': 0}
    joint_type = relations.get("joint_type", "unknown")
    controllable = relations.get("controllable")

    if joint_type in ["fixed", "unrelated", "supported", "flexible"]:
        relation_type = joint_type
    elif controllable:
        relation_type = f"{joint_type}-{controllable}"
    else:
        relation_type = joint_type  # Fallback, though should be covered by above

    root = int(relations.get("root", 0))  # Convert root to integer
    return relation_type, root


def prune_kinematic_relation(relations, dir, CAT):
    relations = detect_conflict_kr(relations, CAT)
    relations = detect_cyclic_kr(relations, CAT)
    relations = detect_redundancy_kr(relations, dir)
    return relations

def create_new_config_json(sample_dir, G, kr_list, pos_dict, new_config_filename="new_config.json"):
    config_path = os.path.join(sample_dir, new_config_filename)
    config_data = {
        "part center": {},
        "kinematic relation": []
    }

    for node in G.nodes:
        part_name = str(node)  # Convert node to string for consistency
        if part_name not in config_data["part center"]:
            # Get the part center from the pos_dict (if available)
            center = pos_dict.get(part_name, [0, 0])  # Default to [0, 0] if not found
            config_data["part center"][part_name] = center

    for u, v, data in G.edges(data=True):
        part1 = str(u)
        part2 = str(v)
        joint_type = data.get("joint_type", "unknown")
        controllable = data.get("controllable", "static")     
        relation_entry = [part1, part2, {"joint_type": joint_type, "controllable": controllable}]
        config_data["kinematic relation"].append(relation_entry)
    
    with open(config_path, "w") as f:
        json.dump(config_data, f, indent=4)
    
    print(f"Created new {config_path}")

#networkX包
#把原本的json文件用原本函数变成G，然后用这个函数测一下relation是否相同

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Prune the kinematic relation generated by VLM"
    )
    parser.add_argument(
        "--dataset_dir", type=str, required=True, help="Path to the PSR dataset"
    )

    args = parser.parse_args()

    sample_list = os.listdir(args.dataset_dir)
    for sample_name in sample_list:
        print(f"Processing {sample_name}...")
        sample_dir = os.path.join(args.dataset_dir, sample_name)
        config_path = os.path.join(sample_dir, "config.json")
        mask_path = os.path.join(sample_dir, "mask0.png")
        src_img_path = os.path.join(sample_dir, "src_img.png")
        with open(config_path, "r") as f:
            psr_dict = json.load(f)
            kr_list = psr_dict["kinematic relation"]
            pos_dict = psr_dict["part center"]
        G = read_rel_as_nx(kr_list, pos_dict)
        G = prune_kinematic_relation(G, sample_dir, PSR_KR_CAT) # prune
        show_graph(G, src_img_path, mask_path)

        create_new_config_json(sample_dir, G, kr_list, pos_dict)

# output modified config.json