import json
import os
import networkx as nx
import argparse
import shutil
from nx_utils.build_nx import read_rel_as_nx
from nx_utils.output_nx import create_new_config_json
from nx_utils.visualize import show_graph

from nx_utils.validate_graph import (
    detect_conflict_kr,
    detect_redundancy_kr,
    detect_cyclic_kr,
    graph_to_tree,
)

PSR_KR_CAT = [
    "fixed",  # keep iff only "fixed" is detected
    "revolute-static",
    "prismatic-static",
    "spherical-static",
    "revolute-controlled",
    "prismatic-controlled",
    "spherical-controlled",
    "revolute-free",
    "prismatic-free",
    "spherical-free",
    "supported",  # keep
    "flexible",  # keep
    "unrelated",  # ignore
    "unknown",  # delete others if detected
]
# order
PSR_FUNC_CAT = [
    "other",
    "handle",
    "housing",
    "support",
    "frame",
    "button",
    "wheel",
    "display",
    "cover",
    "plug",
    "port",
    "door",
    "container",
]


def _parse_relations(relations):
    # relations is expected to be a dictionary, e.g., {'type': 'revolute-free', 'root_index': 0}
    joint_type = relations.get("joint_type", "unknown")
    controllable = relations.get("controllable")

    if joint_type in ["fixed", "unrelated", "supported", "flexible"]:
        relation_type = joint_type
    elif controllable:
        relation_type = f"{joint_type}-{controllable}"
    else:
        relation_type = joint_type  # Fallback, though should be covered by above

    root = int(relations.get("root", 0))  # Convert root to integer
    return relation_type, root


def prune_kinematic_relation(relations, dir, CAT):
    try:
        relations = detect_conflict_kr(relations, CAT)
        relations = detect_cyclic_kr(relations, CAT)
        relations, root = graph_to_tree(relations)
    except Exception as e:
        print(e)
        return None, False
    relations = detect_redundancy_kr(relations, root, dir)
    return relations, True


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Prune the kinematic relation generated by VLM"
    )
    parser.add_argument(
        "--dataset_dir", type=str, required=True, help="Path to the PSR dataset"
    )
    parser.add_argument(
        "--trash_dir",
        type=str,
        required=True,
        help="Path to the removed PSR dataset sample",
    )

    args = parser.parse_args()
    trash_dataset_dir = args.trash_dir
    if not os.path.exists(trash_dataset_dir):
        print(f"Creating prune trash dataset directory: {trash_dataset_dir}")
        os.makedirs(trash_dataset_dir)

    sample_list = os.listdir(args.dataset_dir)
    for sample_name in sample_list:
        print(f"Processing {sample_name}...")
        sample_dir = os.path.join(args.dataset_dir, sample_name)
        config_path = os.path.join(sample_dir, "config.json")
        mask_path = os.path.join(sample_dir, "mask0.png")
        src_img_path = os.path.join(sample_dir, "src_img.png")
        with open(config_path, "r") as f:
            psr_dict = json.load(f)
            kr_list = psr_dict["kinematic relation"]
            pos_dict = psr_dict["part center"]
        G = read_rel_as_nx(kr_list, pos_dict)
        # show_graph(G, src_img_path, mask_path)
        G, valid = prune_kinematic_relation(G, sample_dir, PSR_KR_CAT)  # prune
        if valid:
            # show_graph(G, src_img_path, mask_path)

            create_new_config_json(
                sample_dir,
                G,
                kr_list,
                pos_dict,
                new_config_filename="pruned_config.json",
            )
        else:
            print(f"Failed to prune {sample_name}, move to trash!!")
            destination_path = os.path.join(trash_dataset_dir, sample_name)
            try:
                shutil.move(sample_dir, destination_path)
                print(f"Moved {sample_name} to {destination_path}")
            except Exception as e:
                print(f"Error moving {sample_name}: {e}")
